# @fiap-farms/core

This package implements a Clean Architecture approach for the FIAP Farms application, providing a robust, scalable, and testable foundation for business logic.

## Clean Architecture Implementation

This document explains the Clean Architecture implementation in the `@fiap-farms/core` package.

### Architecture Layers

The package follows the Clean Architecture principles with clear separation of concerns:

```
src/
├── domain/                 # Core business logic (no external dependencies)
│   ├── entities/          # Business entities (TypeScript interfaces)
│   └── repositories/      # Repository interfaces (ports/contracts)
├── application/           # Application business rules
│   └── use-cases/         # Use cases orchestrating domain logic
└── infrastructure/        # External concerns (databases, etc.)
    └── repositories/      # Repository implementations (adapters)
        └── firestore/     # Firestore-specific implementations
```

### Dependency Rule

Dependencies only point inward following the Clean Architecture principle:

```
Infrastructure → Application → Domain
```

- **Infrastructure** can import from Application and Domain
- **Application** can import from Domain only
- **Domain** imports nothing from other layers (pure business logic)

This ensures that core business logic remains independent of frameworks, databases, and UI concerns.

### Benefits

1. **Testability**: Mock repository interfaces to test use cases in isolation
2. **Framework Independence**: Business logic doesn't depend on React, Firebase, etc.
3. **Database Flexibility**: Swap Firestore for another database without changing business logic
4. **Maintainability**: Changes in one layer don't affect others
5. **Clear Boundaries**: Each layer has a specific responsibility

## Domain Layer - Core Entities

### Product

```typescript
interface Product {
  _id: string; // Generated by Firestore
  name: string;
  description: string;
  unit: 'kg' | 'unity' | 'box';
  costPerUnit: number;
}
```

_Note: Products are global entities and don't have owners_

### ProductionItem

```typescript
interface ProductionItem {
  _id: string; // Generated by Firestore
  productId: string;
  ownerId: string; // Belongs to a specific farmer
  status: 'planted' | 'in_production' | 'harvested';
  plantedDate: Date;
  expectedHarvestDate: Date;
  harvestedDate?: Date;
  yield?: number;
  location: string;
  updatedAt: Date;
}
```

### InventoryItem

```typescript
interface InventoryItem {
  _id: string; // Generated by Firestore
  ownerId: string; // Belongs to a specific farmer
  productId: string;
  productName: string;
  quantity: number;
  unit: 'kg' | 'unity' | 'box';
  updatedAt: Date;
}
```

_Note: Inventory is read-only from frontend. Updates are handled by backend functions_

### Sale

```typescript
interface SaleItem {
  productId: string;
  productName: string;
  quantity: number;
  pricePerUnit: number;
  totalProfit?: number;
}

interface Sale {
  _id: string; // Generated by Firestore
  ownerId: string; // Belongs to a specific farmer
  saleDate: Date;
  items: SaleItem[];
  totalSaleAmount: number;
  totalSaleProfit?: number;
  client: string;
}
```

## Application Layer - Use Cases

The application layer contains use cases that orchestrate business workflows using domain entities and repository interfaces.

### Currently Implemented Use Cases

#### Production Management

- **StartNewProductionUseCase** - Create new production items
- **HarvestProductionItemUseCase** - Mark production as harvested with yield
- **GetProductionOverviewUseCase** - Get production dashboard data

#### Sales Management

- **RegisterSaleUseCase** - Register new sales with inventory validation
- **GetSalesDashboardDataUseCase** - Get sales analytics and dashboard data

#### Inventory Management

- **GetInventoryOverviewUseCase** - Get current inventory status

#### Product Management

- **GetProductsUseCase** - Retrieve available products

### Example Usage Flow

1. **UI Layer** (React/React Native) calls a use case
2. **Use Case** (Application Layer) orchestrates business logic using entities
3. **Use Case** calls repository interface methods
4. **Repository Implementation** (Infrastructure) handles database operations
5. **Repository Implementation** returns domain entities
6. **Use Case** returns results to UI Layer

### Usage Examples

#### Starting a New Production

```typescript
import {
  StartNewProductionUseCase,
  FirestoreProductionRepository,
} from '@fiap-farms/core';

const productionRepo = new FirestoreProductionRepository();
const useCase = new StartNewProductionUseCase(productionRepo);

const newProduction = await useCase.execute({
  productId: 'product-123',
  ownerId: 'user-456',
  location: 'Field A',
  expectedHarvestDate: new Date('2024-12-01'),
});
```

#### Harvesting Production

```typescript
import {
  HarvestProductionItemUseCase,
  FirestoreProductionRepository,
} from '@fiap-farms/core';

const productionRepo = new FirestoreProductionRepository();
const useCase = new HarvestProductionItemUseCase(productionRepo);

await useCase.execute({
  productionItemId: 'production-123',
  yieldAmount: 150,
});

// Note: Inventory updates are handled automatically by backend functions
```

#### Registering a Sale

```typescript
import {
  RegisterSaleUseCase,
  FirestoreSaleRepository,
  FirestoreInventoryRepository,
} from '@fiap-farms/core';

const saleRepo = new FirestoreSaleRepository();
const inventoryRepo = new FirestoreInventoryRepository();
const useCase = new RegisterSaleUseCase(saleRepo, inventoryRepo);

const sale = await useCase.execute({
  ownerId: 'user-456',
  client: 'Restaurant ABC',
  items: [
    {
      productId: 'product-123',
      productName: 'Tomatoes',
      quantity: 50,
      pricePerUnit: 8.5,
    },
  ],
});

// Note: Inventory decreases are handled automatically by backend functions
```

## Infrastructure Layer - Repository Implementations

All repository interfaces are implemented for Firestore in the infrastructure layer:

### Available Repository Implementations

- **FirestoreProductRepository** - Full CRUD operations for products (global, no owners)
- **FirestoreProductionRepository** - Full CRUD operations for production items (owner-specific)
- **FirestoreInventoryRepository** - **Read-only** operations (updates handled by backend)
- **FirestoreSaleRepository** - Full CRUD operations for sales (owner-specific)

### Repository Interface Examples

#### IProductionRepository

```typescript
interface IProductionRepository {
  create(item: Omit<ProductionItem, '_id'>): Promise<ProductionItem>;
  findByOwner(ownerId: string): Promise<ProductionItem[]>;
  findById(itemId: string): Promise<ProductionItem | null>;
  updateStatus(itemId: string, status: ProductionStatus): Promise<void>;
  setAsHarvested(itemId: string, yieldAmount: number): Promise<void>;
  findByProduct(productId: string): Promise<ProductionItem[]>;
  findByStatus(status: ProductionStatus): Promise<ProductionItem[]>;
}
```

### Important Implementation Notes

1. **Firestore ID Generation**: The `_id` field is automatically generated by Firestore, so create operations use `Omit<Entity, '_id'>`

2. **Inventory Operations**: Inventory updates (increase/decrease quantities) are handled by backend functions/triggers, not directly by the frontend. The frontend only reads inventory data for validation and display purposes.

3. **Product Ownership**: Products are global entities without owners. Only Production, Inventory, and Sales are owner-specific.

4. **Status Management**: Production items have a clear lifecycle: `planted` → `in_production` → `harvested`

## Usage in React/React Native Applications

### Custom Hook Example

```typescript
// hooks/useStartProduction.ts
import { useState } from 'react';
import {
  StartNewProductionUseCase,
  FirestoreProductionRepository,
  ProductionItem,
} from '@fiap-farms/core';

export function useStartProduction() {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const startProduction = async (data: {
    productId: string;
    ownerId: string;
    location: string;
    expectedHarvestDate: Date;
  }): Promise<ProductionItem | null> => {
    setIsLoading(true);
    setError(null);

    try {
      const productionRepo = new FirestoreProductionRepository();
      const useCase = new StartNewProductionUseCase(productionRepo);
      const result = await useCase.execute(data);

      setIsLoading(false);
      return result;
    } catch (err) {
      setError(err as Error);
      setIsLoading(false);
      return null;
    }
  };

  return { startProduction, isLoading, error };
}
```

### Component Integration

```typescript
// components/ProductionForm.tsx
import React from 'react';
import { useStartProduction } from '../hooks/useStartProduction';

export function ProductionForm() {
  const { startProduction, isLoading, error } = useStartProduction();

  const handleSubmit = async (data: FormData) => {
    const result = await startProduction({
      productId: data.productId,
      ownerId: data.ownerId,
      location: data.location,
      expectedHarvestDate: new Date(data.expectedHarvestDate),
    });

    if (result) {
      console.log('Production started:', result);
      // Handle success
    }
  };

  // ... rest of component
}
```

## Testing Strategy

Since the architecture separates concerns cleanly, you can easily test use cases by mocking repository interfaces:

```typescript
import {
  StartNewProductionUseCase,
  IProductionRepository,
  ProductionItem,
} from '@fiap-farms/core';

// Mock repository for testing
const mockRepo: IProductionRepository = {
  create: jest.fn(),
  findByOwner: jest.fn(),
  findById: jest.fn(),
  updateStatus: jest.fn(),
  setAsHarvested: jest.fn(),
  findByProduct: jest.fn(),
  findByStatus: jest.fn(),
};

describe('StartNewProductionUseCase', () => {
  it('should create a new production item with planted status', async () => {
    const expectedResult: ProductionItem = {
      _id: 'generated-id',
      productId: 'product-123',
      ownerId: 'user-456',
      status: 'planted',
      plantedDate: expect.any(Date),
      expectedHarvestDate: new Date('2024-12-01'),
      location: 'Field A',
      updatedAt: expect.any(Date),
    };

    (mockRepo.create as jest.Mock).mockResolvedValue(expectedResult);

    const useCase = new StartNewProductionUseCase(mockRepo);
    const result = await useCase.execute({
      productId: 'product-123',
      ownerId: 'user-456',
      location: 'Field A',
      expectedHarvestDate: new Date('2024-12-01'),
    });

    expect(result).toEqual(expectedResult);
    expect(mockRepo.create).toHaveBeenCalledWith({
      productId: 'product-123',
      ownerId: 'user-456',
      location: 'Field A',
      expectedHarvestDate: new Date('2024-12-01'),
      status: 'planted',
      plantedDate: expect.any(Date),
      updatedAt: expect.any(Date),
    });
  });
});
```

## Package Exports

The package exports all layers following Clean Architecture principles:

```typescript
// Domain Layer - Entities and Repository Interfaces
export * from './domain/entities/product.entity';
export * from './domain/entities/production.entity';
export * from './domain/entities/inventory.entity';
export * from './domain/entities/sale.entity';

export * from './domain/repositories/IProductRepository';
export * from './domain/repositories/IProductionRepository';
export * from './domain/repositories/IInventoryRepository';
export * from './domain/repositories/ISaleRepository';

// Application Layer - Use Cases
export * from './application/use-cases/production/StartNewProduction.usecase';
export * from './application/use-cases/production/HarvestProductionItem.usecase';
export * from './application/use-cases/production/GetProductionOverview.usecase';
export * from './application/use-cases/sales/RegisterSale.usecase';
export * from './application/use-cases/sales/GetSalesDashboardData.usecase';
export * from './application/use-cases/inventory/GetInventoryOverview.usecase';
export * from './application/use-cases/products/GetProducts.usecase';

// Infrastructure Layer - Repository Implementations
export * from './infrastructure/repositories/firestore/FirestoreProductRepository';
export * from './infrastructure/repositories/firestore/FirestoreProductionRepository';
export * from './infrastructure/repositories/firestore/FirestoreInventoryRepository';
export * from './infrastructure/repositories/firestore/FirestoreSaleRepository';
```

## Architecture Benefits Summary

1. **Testability**: Easy to mock dependencies and test business logic in isolation
2. **Framework Independence**: Business logic doesn't depend on React, React Native, Firebase, etc.
3. **Database Flexibility**: Can swap Firestore for another database without changing business logic
4. **Maintainability**: Clear boundaries mean changes in one layer don't affect others
5. **Scalability**: Well-organized structure supports growth and feature additions
6. **Team Productivity**: Different team members can work on different layers independently

## Dependencies

- `@fiap-farms/firebase`: For Firestore database operations and configurations
- `firebase/firestore`: For Firestore SDK types and functions

This architecture provides a solid foundation for building scalable, maintainable applications with clear separation of concerns and high testability.
